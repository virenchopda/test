import 'package:dio/dio.dart' as dio;
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:video_player/video_player.dart';
import 'dart:math' as math;
import 'dart:io';
import 'package:ffmpeg_kit_flutter_new/ffmpeg_kit.dart';
import 'package:ffmpeg_kit_flutter_new/return_code.dart';
import 'package:flutter/services.dart';
import 'package:path_provider/path_provider.dart';



            ElevatedButton(
              onPressed: () {
                final extList = ['mp4', 'mkv'];
                final path = ['test.mp4', 'test.png', 'test1.png', 'test2.png', 'test3.png'];
                final hasVideo = path.isNotEmpty && extList.any((ext) => path.first.endsWith(ext));


                for (final file in path.skip(hasVideo ? 1 : 0)) {
                  // is original position,
                  // is not original position then screenort,
                  print('Image: $file');
                }

                if (hasVideo) {
                  if (path.first.contains('storage')) {
                   // is original position, api  
                   // is not original position, dio download, zoom function call and api with image.  
                    print('Network video');
                  } else {
                   // is original position, api  
                   // is not original position, zoom function call and api with image.
                    print('Local video');
                  }
                }
                else{
                  // api
                }
              },
              child: Text('Zego Test'),
            ),
class VideoDemoBinding extends Bindings {
  @override
  void dependencies() {
    Get.put(VideoDemoController());
  }
}

class VideoDemoController extends GetxController {
  Rx<VideoPlayerController?> videoController = Rx<VideoPlayerController?>(null);

  Rx<VideoPlayerController?> processedVideoController = Rx<VideoPlayerController?>(null);

  RxDouble scale = 1.0.obs;
  RxDouble rotation = 0.0.obs;

  double _previousScale = 1.0;
  double _previousRotation = 0.0;

  Rx<Offset> position = Offset.zero.obs;

  final double viewerWidth = Get.width;
  final double viewerHeight = Get.height * 0.30;

  RxBool isProcessing = false.obs;
  RxBool isDownloading = false.obs;

  void onScaleStart(ScaleStartDetails details) {
    _previousScale = scale.value;
    _previousRotation = rotation.value;
  }

  void onScaleUpdate(ScaleUpdateDetails details) {
    // scale.value = (_previousScale * details.scale).clamp(1.0, 2.0);
    // rotation.value = _previousRotation + details.rotation;
    //
    // if (details.pointerCount == 1) {
    //   position.value += details.focalPointDelta;
    // }

    scale.value = (_previousScale * details.scale).clamp(1.0, 2.0);
    rotation.value = _previousRotation + details.rotation;

    if (details.pointerCount == 1) {
      Offset newPos = position.value + details.focalPointDelta;
      final videoWidth = viewerWidth * scale.value;
      final videoHeight = viewerHeight * scale.value;
      final maxX = (videoWidth - viewerWidth) / 2;
      final maxY = (videoHeight - viewerHeight) / 2;
      final dx = newPos.dx.clamp(-maxX, maxX);
      final dy = newPos.dy.clamp(-maxY, maxY);
      position.value = Offset(dx, dy);
    }
  }

  void onScaleEnd(ScaleEndDetails? onScaleEnd) {
    // const double maxOffset = 100;
    // if (position.value.dx.abs() > maxOffset ||
    //     position.value.dy.abs() > maxOffset) {
    //   position.value = Offset.zero;
    // }
  }

  bool get isInOriginalPosition =>
      (scale.value - 1.0).abs() < 0.01 && position.value.dx.abs() < 0.5 && position.value.dy.abs() < 0.5;

  @override
  void onClose() {
    videoController.value?.dispose();
    processedVideoController.value?.dispose();
    super.onClose();
  }

  Rx<String?> inputFile = Rx<String?>(null);

  Future<void> exportVideo({required String fileVideoPath}) async {
    try {
      print(
        'Original positons:---> ${isInOriginalPosition}   ${position.value} --${scale.value}   ${(scale.value - 1.0).abs() < 0.01}',
      );
      if (isInOriginalPosition) return;

      isProcessing.value = true;

      await processedVideoController.value?.dispose();
      processedVideoController.value = null;

      final tempDir = await getTemporaryDirectory();
      final outputFile = File('${tempDir.path}/output.mp4');
      if (outputFile.existsSync()) {
        await outputFile.delete();
      }

      const quality = 2.0;

      /// Viewer size (output)
      final outW = viewerWidth * quality;
      final outH = viewerHeight * quality;

      /// REAL video size (IMPORTANT)
      // final videoW = videoController.value!.value.size.width;
      // final videoH = videoController.value!.value.size.height;

      final videoW = viewerWidth;
      final videoH = viewerHeight;

      /// BoxFit.cover math
      final coverScale = math.max(outW / videoW, outH / videoH);

      final baseW = videoW * coverScale;
      final baseH = videoH * coverScale;

      /// Apply zoom
      final totalW = baseW * scale.value;
      final totalH = baseH * scale.value;

      /// Clamp pan when scale == 1
      final safePanX = scale.value <= 1.01 ? 0.0 : position.value.dx * quality;
      final safePanY = scale.value <= 1.01 ? 0.0 : position.value.dy * quality;

      /// Center crop
      double cropX = (totalW - outW) / 2 - safePanX;
      double cropY = (totalH - outH) / 2 - safePanY;

      cropX = cropX.clamp(0.0, totalW - outW);
      cropY = cropY.clamp(0.0, totalH - outH);

      final filter =
          'scale=$totalW:$totalH:flags=bilinear,'
          'crop=$outW:$outH:$cropX:$cropY';

      final command =
          '-i "$fileVideoPath" '
          '-vf "$filter" '
          '-c:v libx264 '
          '-preset ultrafast '
          '-pix_fmt yuv420p '
          '-y "${outputFile.path}"';

      await FFmpegKit.executeAsync(command, (session) async {
        final rc = await session.getReturnCode();
        isProcessing.value = false;

        if (ReturnCode.isSuccess(rc)) {
          processedVideoController.value = VideoPlayerController.file(outputFile)
            ..initialize().then((_) {
              processedVideoController.value!.play();
              processedVideoController.refresh();
            });
        } else {
          Get.snackbar('Error', 'Export failed');
        }
      });
    } catch (e) {
      isProcessing.value = false;
      Get.snackbar('Error', e.toString());
    }
  }
}

class VideoDemoView extends GetView<VideoDemoController> {
  const VideoDemoView({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Zoom & Rotate Demo')),
      body: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            ElevatedButton(
              onPressed: () async {
                try {
                  await ImagePicker().pickVideo(source: ImageSource.gallery).then((v) async {
                    if (v != null) {
                      controller.videoController.value = VideoPlayerController.file(File(v.path))
                        ..initialize().then((_) {
                          controller.videoController.value!.play();
                          controller.videoController.refresh();
                        });

                      Uint8List videoBytes = await v.readAsBytes();

                      final tempDir = await getTemporaryDirectory();
                      final inputFile1 = File('${tempDir.path}/input.mp4');
                      await inputFile1.writeAsBytes(videoBytes);

                      controller.inputFile.value = inputFile1.path;
                    }
                  });
                } catch (e) {}
              },
              child: Text('Gallery'),
            ),

            // ElevatedButton(
            //   onPressed: () async {
            //     try {
            //       controller.isDownloading.value = true;
            //       const networkVideo =
            //           'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerEscapes.mp4';
            //       controller.videoController.value = VideoPlayerController.networkUrl(Uri.parse(networkVideo))
            //         ..initialize().then((_) {
            //           controller.videoController.value!.play();
            //           controller.videoController.refresh();
            //         });
            //       dio.Response response = await dio.Dio().get(
            //         networkVideo,
            //         onReceiveProgress: (received, total) {
            //           if (total != -1) {
            //             print("${(received / total * 100).toStringAsFixed(0)}% -------------------------");
            //           }
            //         },
            //         options: dio.Options(
            //           responseType: dio.ResponseType.bytes,
            //           followRedirects: false,
            //           validateStatus: (status) => status! < 500,
            //         ),
            //       );
            //       final tempDir = await getTemporaryDirectory();
            //       final inputFile1 = File('${tempDir.path}/input.mp4');
            //       await inputFile1.writeAsBytes(response.data);
            //       controller.inputFile.value = inputFile1.path;
            //     } catch (e) {
            //     } finally {
            //       controller.isDownloading.value = false;
            //     }
            //   },
            //   child: Text('Network'),
            // ),
            Obx(
              () => (controller.inputFile.value ?? '').isNotEmpty
                  ? ElevatedButton(
                      onPressed: controller.isDownloading.value
                          ? null
                          : () {
                              controller.exportVideo(fileVideoPath: controller.inputFile.value ?? "");
                            },
                      child: controller.isDownloading.value
                          ? SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(color: Colors.white, strokeWidth: 3),
                            )
                          : Text('Crop'),
                    )
                  : SizedBox.shrink(),
            ),
            SizedBox(height: 10),
            const Text('Original Video (Zoom & Rotate)', style: TextStyle(fontWeight: FontWeight.bold)),
            SizedBox(height: 10),
            Obx(() {
              final vc = controller.videoController.value;
              if (vc == null) {
                return SizedBox(
                  height: controller.viewerHeight,
                  width: controller.viewerWidth,
                  child: ColoredBox(color: Colors.grey.shade300),
                );
              } else if (!vc.value.isInitialized) {
                return SizedBox(
                  height: controller.viewerHeight,
                  width: controller.viewerWidth,
                  child: Center(child: CircularProgressIndicator()),
                );
              }
              return ClipRect(
                child: SizedBox(
                  width: controller.viewerWidth,
                  height: controller.viewerHeight,
                  child: GestureDetector(
                    onScaleStart: controller.onScaleStart,
                    onScaleUpdate: controller.onScaleUpdate,
                    onScaleEnd: controller.onScaleEnd,
                    child: Transform(
                      alignment: Alignment.center,
                      transform: Matrix4.identity()
                        ..translate(controller.position.value.dx, controller.position.value.dy)
                        ..scale(controller.scale.value),
                      child: SizedBox(width: vc.value.size.width, height: vc.value.size.height, child: VideoPlayer(vc)),
                    ),
                  ),
                ),
              );
            }),

            const SizedBox(height: 24),

            const Text('Processed Video', style: TextStyle(fontWeight: FontWeight.bold)),
            const SizedBox(height: 10),

            Obx(() {
              final pc = controller.processedVideoController.value;
              if (controller.isProcessing.value) {
                return SizedBox(
                  height: controller.viewerHeight,
                  width: controller.viewerWidth,
                  child: Center(child: CircularProgressIndicator()),
                );
              } else if (pc == null) {
                return SizedBox(
                  height: controller.viewerHeight,
                  width: controller.viewerWidth,
                  child: ColoredBox(color: Colors.grey.shade300),
                );
              }

              return ClipRect(
                child: SizedBox(width: controller.viewerWidth, height: controller.viewerHeight, child: VideoPlayer(pc)),
              );
            }),
          ],
        ),
      ),
    );
  }
}
